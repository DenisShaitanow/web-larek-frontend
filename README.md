# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом
- src/types - папка с файлами типизации компонентов

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```



Архитектура приложения.
Приложение представляет собой интернет магазин в котором пользователю будут доступны следующие дейстивия.
- Просмотр списка товаров, полученного от сервера.
- Выбор товара для более подробного изучения. Откроется модальное окно карточки товара.
- Пользователь может положить товар в корзину.
- Открытие корзины и просмотр списка выбранных товаров.
- Возможность удалить товар из корзины как из модального окна карточки товара, так и из корзины.
- Оформление заказа, ввод контатных данных и выбор способа оплаты. 
- Совершение покупки, путем нажатия соответствующей кнопки. 

В реализации я буду использовать паттерн MVP.
Модель будет работать с данными, совершать запросы на сервер.
Отображение отвечает за перенос данных в верстку, слежение за действиями пользователя.
Презентер связывает между собой модели данных и отображение. Презентер имеет преимущество, заключающееся в том, что появляется возможность отдельной отладки, как Модели так и Вью, хотя я откровенно говоря, отдельно ничего не отлаживал.

Проанализирую данные, с которыми мне придется работать.

1. Объект товар. Его компонент - это карточка товара. Коллекция этих карточек будет отображена на главной странице, при клике на товар будет отображаться более подробная информация. Она же в скоращенном виде отображается в списке в корзине.
interface IProduct {
    id: string;
    title: string;
    category: string;
    description: string;
    price: number;
    image: string;
}

id - индивидуальный идентификационный номера товара.
title - название товара
category - категория товара
description - подробное описание товара
price - цена товара
image - адрес ссылки на изображение товара

Когда я делаю запрос серверу для получения карточек товара я получаю ответ такого формата:
IProductResponse {
    total: number;
    items: IProduct[];
}  где

total - количество товаров (10шт.),
items - массив объектов, тип которых приведен выше.

2. Объект личные данные описан через интерфейс.
Этот объект данных необходим для отправки заказа на сервер.

interface Personal_information {
    pay: "personally" | "online";
    mail: string;
    phone: string;
    address: string;
}

pay - Тип оплаты, который выбрал пользователь
mail - почта пользователя
phone - телефон пользователя
address - адрес пользователя


3. Объект данных, которые я получаю при ответе сервера после успешно обработанного заказа.

IOrder {
    idOrder: string;
    totalOrder: number; }

    idOrder - идентификатор заказа, который при необходимости можно отобразить в верстке.
    totalOrder - общая сумма заказа.

4. Еще один объект данных необходим для формирования заказа и отправки его на сервер.

type OrderData = {
    payment: "personally" | "online";
    email: string;
    phone: string;
    address: string;
    total: number;
    items: string[];
} сюда входят персональные данные, общая сумма заказа, и список идентификаторов товаров.

Далее рассмотрим классы модели данных.
_______

Класс Personal_information предназначен для создания объекта, который принимает контактные данные пользователя. ДАлее отсюда эти данные берутся для отправки их на сервер.
Его поля:
pay: "personally" | "online"; - Тип оплаты, который выбрал пользователь. Лично (карта или кэш) или онлайн.
mail - почта пользователя
phone - телефон пользователя
address - адрес пользователя

Конструктор пустой.

В классе будет 4 сеттера для заполнения вышеказанных полей.
set paySet(value: "personally" | "online");
set mailSet(value: string);
set phoneSet(value: string);
set addressSet(value: string);


______


Класс "Корзина" Busket. 

Класс создает объект, в поля которого я буду записывать данные корзины.
 Поля:
    productList - список выбранных товаров типа IProduct, этот список необходим для рендеринга корзины и карточек товара.
    total_price - общая сумма заказа. Необходима для отображения в окне корзины.
    id_list - список идентификационных номеров выбранных товаров. Этот список затем попадает в заказ и отправляется на сервер.

 Конструктор пустой.

 Методы:
- Метод удаления из корзины. При нажатии на крестик,товар удаляется из корзины. Массив идентификаторов и массив товаров становятся пустыми, общая сумма заказа обнуляется.

- 3 сеттера вышеказанных полей и два геттера (общая сумма и список идентификаторов) для получания данных из полей.

_______________________________________________________________

Класс Order. Этот клас создает объект, который сохраняет данные заказа, которые отправляет в нашу сторону сервер после обработки данных.

Поля:
totalOrder - Общая сумма покупки;
idOrder - Идентификатор заказа;

Конструктор пустой.
 ____
 Методы:
- В классе предусмотрено два сеттера для записи этих полей.

__________________________________________________

Основной класс LarekModel. Он создает объект, который собирает в себя вышерассмотренные объекты данных, сохраняет массив карточек для отображения.

Он включает в себя следующие поля:
productList - Поле productList коллекция карточек явялестя массивом объектов класса IProduct. Сюда я сохраняю данные от сервера, которые потом используются для рендеринга карточек.
personalInformation - поле персональной информации. Класс уже рассмотерн выше.
busket - объект корзины. Класс уже рассмотерн выше.
order - объект заказа. Класс уже рассмотерн выше.
api - объект апи. Этот класс находится в базовом коде. В нем находятся методы запроса на сервер, проверка кода ответа. Обработка ошибок. 

Конструктор класса принимает аргументами следующие объекты:
   personalInformation - данные для заказа
   busket - коризна
   order - данные о заказе.
   api - апи сервера

Рассмотрим методы класса

- getProductList метод отправляет запрос на загрузку карточек товара на сервер, получая ответ, записывает его в поле productList.
- doPay метод, инициирующий совершение покупки. Данные со списком товаров и контактных данных отправляются на сервер. Ответ от сервера будет записан в объет Order с помощью сеттера этого класса.
- selectProduct метод, делающий сапрос на сервер по ИД товара(аргумент метода) и получающий данные о товаре. Данные возвращаются типом IProduct. Аргументом метода является идентификатор товара типа string.

________________________________________________________



Далее рассмтотрим классы VIEW.

Начну с компонентов, далее перейду к основному классу. 

___________________________________________________
Первый класс ModalWindow. Модальное окно. Он отвечает за работу с модальным окном.
В нем располагается всего одно поле:
modalWindow - в нем я записываю ДОМ элемент модального окна, чтобы в других функциях не пользоваться аргументами. Функции и так понимают, что открыть и что закрыть. Проект построен таким образом, что модальное окно одно, но в него каждый раз вставляется разный контент. Будь то карточка товара или корзина, или успешное выполнение заказа.

В конструкторе я сразу прописал обращение к методу, который заполняет поле найденным в верстке ДОМ элементом модального окна.

Методы класса: 

addModalWindowDom - принимают аргументом место в верстке строчного типа и далее по нему, найдя эелемент, записывает его в поле modalWindow.

openModalWindow - открывает модальное окно.

closeModalWindow - закрывает модальное окно.

handleEscKeyUp - метод коллбэк. Слушает клавиатуру во время открытия модального окна, при нажатии на Энтер, вызывает метод закрытия модального окна.

_____________________________________________________

Следующий класс-компонент Validation. Он отвечает за валидацию полей ввода, в тех формах ввода, которые есть в проекте. 

formList - единственное поле класса, список форм. 
Record <string, FormForValidation> - формат этого поля подразумевает название формы, которое задает разработчик, и объект данных о форме, типизацию которого я привожу ниже

type FormForValidation = { - тип формы для валидации
    formValidation: HTMLFormElement;
    inputList: HTMLInputElement[];
    validity: boolean
}

здесь 
formValidation - в этом поле я сохраняю ДОМ элемент формы
inputList - список инпутов, которые находятся в форме
validity - статус валидации. T - форма валидна, F - форма не валидна.

Конструктор класса пустой.

Методы:
  formListSet - первый метод отвечает за запись поля formList. У метода есть 3 аргумента, 
1. Название формы,
2. ДОМ формы
3. Общий класс инпута. Для поиска инпутов внутри формы.
Метод формирует данные для поля и записывает их туда.

setEventListeners - метод устанавливает слушатели на инпуты, принимая на вход строчное значение название формы. ПРоверяет наличие формы в поле, и назначет слушатели. При каждом изменении инпута, метод инициилизирует методы, которые будут рассмотрены далее.

checkInputValidity - метод занимает непосредственно валидацией инпута. Принимает на вход два аргумента, инпут и форму, в которой инпут располагается. Если инпут невалиден, метод инициилизирует метод показа ошибки валидации, если валиден скрывает его.

showInputError - метод отвечает за показ ошибки валидации принимает аргументами текст ошибки для показа и форму, где ее нужно показать. 

hideInputError - метод скрывает ошибку валидации, аргументом принимает только форму (где скрыть).

toggleState - в зависимости от результата валидации инпута, метод меняет значение validity в поле, formList в соответствующей форме. Далее это значение будет использовать в классе VIEW, для деактивации/активации кнопки, отвечающей за сабмит формы. 

clearValidation - метод отвечает за сброс валидации. Аргументом является название формы строчного типа. Его я запускаю при открытии формы, чтобы удалить результаты прошлого ввода.

________________________________________________________

Основной класс отображения VIEW.

Объект этого класса отвечает за визуальную часть, рендеринг элементов верстки, реакция на действия пользователя, запуск брокера событий.

Поля:

validation - здесь я храню объект, отвечающий за валидацию. (рассмотрен выше). Задается через конструктор.

modalWindow - объект отвечает за работу модального окна. (рассмотрен выше) Задается через конструктор.

emitter - объект, отвечающий за брокер событий. Класс хранится в базовом коде. Задается через конструктор.

uppendPlaces: Record<string, HTMLElement> - поле хранящее массив объектов { название место для аппенда, ДОМ места для аппенда}. Это поле используется в методе uppendElement, который берет ДОМ элемент(из аргумента) и помещает его в место для аппенда из этого поля. 

headerBusketButton - поле, хранящее ДОМ элемент кнопки корзины на главной странице. Задается в конструкторе.

headerBusketButtonCounter - поле, хранящее ДОМ счетчика кнопки корзины. Меняющее количество товаров в ней. Задается в конструкторе.

Basket - поле, хранящее ДОМ верстки корзины. Задается в конструкторе.

templateCardCatalog - поле, хранящее ДОМ шаблона карточки товара в формате главная страница. В методе рендеринга карточки я его буду отсюда брать и копировать.

templateCardPreview - поле, хранящее ДОМ шаблона карточки товара в формате подробная карточка(модальное окно). В методе рендеринга карточки я его буду отсюда брать и копировать.

templateCardBasket - поле, хранящее ДОМ шаблона карточки товара в формате карточка для корзины. В методе рендеринга карточки я его буду отсюда брать и копировать.

orderWindow - поле, хранящее ДОМ окна заказа товара. Задается в конструкторе.

listenersOrderAttached - поле хранит информацию о том, установлены ли слушатели на форму "Заказ". Если это поле хранит ТРУ, значит при рендеринге окна заказа слушатели по второму разу не навешиваются, идет сразу рендеринг в модальное окно. Задается в конструкторе.

orderData - поле хранит данные, которые собирает форма и отправляет их в модель для обработи. 
{ pay: "personally" | "online" | null, address: string} тип данных, выбор оплаты, и строчное значение адреса. Задается в конструкторе.

contactsWindow - поле, хранящее ДОМ окна заказа товара, где пользователь вводит телефон и почту. Задается в конструкторе.

listenersContactsAttached - поле хранит информацию о том, установлены ли слушатели на форму "Контакты". Если это поле хранит ТРУ, значит при рендеринге окна заказа слушатели по второму разу не навешиваются, идет сразу рендеринг в модальное окно.

contactsData - поле хранит данные, которые собирает форма и отправляет их в модель для обработи.
{mail: string, phone: string} Почта и телефон тип стринг.

Конструктор класса:
В конструкторе я решил задать все поля, чтобы не перегружать его сеттерами. Единственное поле, для записи которого я сделал метод,  этоuppendPlaces. 

Также в констукторе я подписываюсь на событие Удалить из корзины. Чтобы, когда пользователь удалил товар из корзины, он пропал из верстки.

Методы:

init() в этот метод я убрал действия, которые изначально были в точке входа. В нем я создаю три места для аппенда в верстку. Галерея, куда будут вводиться карточки на главную страницу, корзина, и модальное окно. 

addAppendPlace - метод для добавления мест для аппенда, аргументы: название места и ДОМ этого места. 

startStartListeners - метод установки начальных слушателей. Здесь я вешаю слушатель на кнопку корзины, кнопку закрытия модального окна. В принципе кнопку тоже можно было вывести в поле класса.
Также я вешаю слушатель на модальное окно, чтобы он слушал нажатие мышки на окрестности окна и закрывал его. Последнее, что я делаю, формирую список форм и вешаю слушатели на их инпуты. 

emptyButtonBasketCounter - метод обнуления счетчика количества товаров на кнопке корзины.

renderCardsArray - метод, запускающий рендеринг массив карточек товара. Он принимает на вход массив каточек своим отдельным для вью интерфейсом, 
тип карточки, этот аргумент может быть 3х значений type TemplateCardType =  "CardCatalog" | "CardPreview" | "CardBasket";
место для аппенда (куда поместить),
doEmpty - необходимость отчистки места для аппенда перед аппендом. 

renderCard - метод рендеринга одной карточки. Метода копиркет шаблон из соотв. поля, наполняет его данными из 1го аргумента (данные карточки ), тип рендеринга (в каком виде собрать) указывается вторым аргументом, 3й аргумент- числовое значение порядкого номера товара. Он необходим для отображения товаров в корзине по номерам.
Метод возвращает готовую для апенда картчоку, но сам апенд не запускает.

renderBusket - метод рендерит и выводит в модальное окно (аппенд) корзину. На вход он получает массив карточек товара и общую стоимость для отображения в корзине.

removeProductFromBusketList - метод удаляет товар из корзины. Аргументом он принимает идентификатор твоара, ищет его по id в верстве и удаляет из версткию

renderOrderFirst - метод рендерит и выводит в модальное окно, окно заказа, где пользователь выбирает тип оплаты и вводит адрес. Аргументов нет. Данные из формы записываются в поле orderData. Если кнопка сабмита доступна для нажатия, инициилизируется соотв. событие в брокере событий, с данными.

renderOrderContacts - метод рендерит и выводит в модальное окно, окно второй части заполнения заказа. Где пользователь вводит телефон и почту. Данные из формы записываются в поле contactsData.
Если кнопка сабмита доступна для нажатия, инициилизируется соотв. событие в брокере событий, с данными.

renderPayDone - метод рендерит и выводит в модальное окно, окно оплата прошла успешно. Аргументом принимается сумма из заказа для вывода в верстку окна.

uppendElement - метод для вывода контента в нужное место верстки. Первый аргумент элемент (что вывести), второй место из поля места для апенда (куда вывести), 3й аргумент типа boolean, отвечающий за необходимость очистки соежржимого перед апендом. Когда выводятся карточки и модальные окна, содержимое отчищается, когда товар добавляется в корзину к другими товарам, содержимое остается нетронутым.


____________________________________________________________________________

Теперь переходим к презентеру. 

Класс Presenter.

3 поля:

larekModel - объект модели
view - объект отображения
emitter - объект брокера событий

Конструктор:

здесь я записываю 3 поля из аргументов конструктора.
Плюс к этому подписываюсь на события,
openBusket - открыть корзину,
addToBusket - добавить в корзину товар
deleteFromBusket - удалить из корзины
deleteFromBusketModel - удалить из корзины, только из модели. Это когда внутри карточки товраа  пользователь передумал и удалил товарз из корзины.
openOrder - открыть окно оформления заказа
orderContinue - открыть окно ввода контактов, продолжение заказа.
doPay - совершение оплаты и вывод окна "заказ оформлен".
newBuys - переход к выбору товаров, после оформления заказа
selectProduct - выбор продукта, открывает окно с подробным описанием товара.

Методы:

async init - метод инициилизирует загрузку и вывод картчоек на страницу, установку стартовых слушателей. Метод асинхронный, так как использует обращение к серверу.

async renderProductList - метод делает запрос на сервер, получает массив карточек, отдает их во вью для вывода на экран.

openOrder - открытия окна оформления заказа. ДАет команду Вью отрендерить окно и открыть модальное окно.

orderContinue - метод продолжения заказа. Берет аргументом данные из формы типа
 { pay: "personally" | "online" | null, address: string; }
записывает их в модель. Выводит продолжение оформления заказа, точнее дает команду ВЬЮ сделать это.

 doPay - метод оплаты заказа. Принимает аргументом данные почты и телефона, отдает их модели, ппросит модель отправить заказ на сервер, дает команду ВЬЮ вывести следующее окно об успешной проводке заказа (аргументом прокидывается общая сумма заказа). В конце очищается корзина.

 newBuys - метод реагирует на событие "к новым покупкам". Модальное окно оформления заказа закрывается. Заново загружаются картчоки товара на стартовую страницу. 

selectProduct - метод получает аргументом на вход идентификатор товара типа стринг. Просит модель обратится к серверу и получить данные на этот товар, далее загруженные данные отдаются ВЬЮ для рендеринга более подробной карточки. ВЬЮ открывает модальное окно.

deleteProductFromBusket - метод принимает идентификатор товара типа стринг, ищет его в верстке и дает команду ВЬЮ удалить его из верстки, а модели удалить его из корзины.

deleteProductFromBusketModel - метод дает команду молдели удалить товар из верстки (по id). Он срабатывает на событие удаления товара из корзины не из модального окна корзины, а из подробной карточки товара. Когда из верстки удалять не нужно, а только из модели.

addToBusket - метод принимает на вход id товара строчного типа, находит его в списке товаров модели productList, дает модели команду добавить товар в корзину отдав им найденный товар аргументом IProduct. Инициилизируется 3 сеттера из объекта корзина в модели.

openBusket - метод срабатыает но событие нажатия кнопки корзины. Дается команда ВЬЮ открыть модальное окно корзины, аргументом для ВЬЮ отдается список выбранных товаров и общая сумма покупки, все это берется из соответствующих полей объекта корзина в модели данных.




______________________________________________________________________________________

Привожу пример работы. 

1. Запускается метод init в презентере, внутри которого запускается метод инит от вью, в котором назначаются места для аппенда отрендеренных элементов. Так же я инициирую вызов метода(во  ВЬЮ)  для назначения слушателей на кнопку, модального окна для закрытия, крестика (кнопки закрытия).
Далее запускаю метод презентера renderProductList.
2. В этом методе я прошу моедль получить данные о товарах с сервера и отдаю их аргументом методу рендеринга массива карточек с последующим аппендом в место, которое обозначено в первом пункте.
3. При нажатии на карточку товара, слушатель которой вешается на нее в процессе рендеринга, вызывает через брокер события вызов метода в презентере selectProduct, аргументом этого метода является идентификатор продукта, который хранится в созданном(через dataset) атрибуте id.
Метод selectProduct вызывает метод получения информации о картчоки в модели, формирует данные в формат, соответсвующий ВЬЮ и отдает методу рендеринга картчоки (тип картчоки: Кард ПРевью) и методу аппенда карточки(выведи срендеренное в модальное окно), модальное окно откроется. Фактически интерфейс ProductSettings идентичен интерфейсу IProduct, просто первый формулирует данные для ВЬЮ, а второй для модели.
4. Если пользователь нажимает кнопку добавить в корзину, происходит поиск по атрибуту id товара в списке всех карточек, который хранится в поле модели данных, если таковой находится, а его не может не быть, товар добавляется в объект корзины в модели данных.











    